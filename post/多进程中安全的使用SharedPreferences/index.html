
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>多进程中安全的使用 SharedPreferences | Melody</title>
<meta name="description" content="Keep Alive.">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://imhanjie.github.io//favicon.ico?v=1569399181915">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://imhanjie.github.io//styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://imhanjie.github.io/">
        <img class="avatar" src="https://imhanjie.github.io//images/avatar.png?v=1569399181915" alt="" width="32px" height="32px">
      </a>
      <a href="https://imhanjie.github.io/">
        <h1 class="site-title">Melody</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">多进程中安全的使用 SharedPreferences</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2016-08-04</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://imhanjie.github.io//tag/android">
                    Android
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p>介绍在多进程中如何安全的使用SharedPreferences来存储和读取数据</p>
<!--more-->
<h3 id="一-一般情况下多进程中直接使用sharedpreferences的影响">一、一般情况下多进程中直接使用SharedPreferences的影响</h3>
<p>SharedPreferences是Android中一种轻量级的存储解决方案，底层采用的是XML文件并且通过键值对的方法来管理数据，所以一般用来存储一些App的配置文件和一些轻量的数据。SharedPreferences使用起来也比较方便简单，但是在多进程情况下使用，SharedPreferences就并不显得那么友好了。在多进程中使用SharedPreferences可能会造成读取到数据为脏数据，还有可能在读写的时候造成数据的丢失。</p>
<p>下面分析一下原因：</p>
<p>系统对SharedPreferences的读写是有一定的缓存机制的，通俗点意思就是操作SharedPreferences时，每个进程都会有一份它的缓存，你对它的操作都会先写到缓存内，然后系统会在合适的时机将缓存里的数据写到文件内。所以在多进程环境中，每个进程都会有一份其缓存，所以在另一个进程中操作了SharedPreferences，另一个进程并不能及时更新数据，这样在读取数据的时候极有可能读取到的不是最新的值，依旧是旧的数据。</p>
<p>我也看到过网上的解决方案，将MODE_PRIVATE改成MODE_WORLD_READABLE或者MODE_WORLD_WRITEABLE之类的，我也尝试过，但还是失败，这两个参数在API 17开始就被废弃了，并且在Android N开始使用这两个参数会抛出安全异常，下面是<a href="https://developer.android.com/reference/android/content/Context.html#MODE_WORLD_READABLE">官方的文档</a>：</p>
<blockquote>
<p>Note: The constants MODE_WORLD_READABLE and MODE_WORLD_WRITEABLE have been deprecated since API level 17<br>
<strong>As of N attempting to use this mode will throw a SecurityException.</strong></p>
</blockquote>
<h3 id="二-解决方案">二、解决方案</h3>
<p>前面也也说道在多进程环境下使用SharedPreferences会不安全，所以我们要做的就是把所有对SharedPreferences的操作放在一个进程，其他进程的想要对SharedPreferences操作，则将他们的操作全部转移到这个进程，所以这样使用SharedPreferences就也没什么问题了。</p>
<p>所以需要用到跨进程传递数据了，Android中的跨进程通信(IPC)的解决方案也有很多，例如使用AIDL、Messenger、ContentProvider、文件共享机制、Socket通信等。AIDL使用起来相对其他的方案比较麻烦。。</p>
<p>**解决方案：<br>
使用ContentProvider封装SharedPreferences的所有操作,ContentProvider的底层使用就是AIDL，只不过ContentProvider已经为我们做了很好的封装了<br>
**</p>
<div align=center>
![](http://i.imgur.com/yuV0Gbl.png)
实现流程图
</div>
<h3 id="三-具体实现">三、具体实现</h3>
<p>这里就不介绍ContentProvider的基本使用用法了，需要说明的是这里用不到ContentProvider的query、getType、insert、delete、update这几个方法，因为这几个方法是系统方便我们用ContentProvider封装数据库的操作的，显然，我们这里是自己封装SharedPreferences，不需要用到数据库，所以这几个方法用不到。而我们需要用到它的call方法，下面看call方法的参数：</p>
<pre><code class="language-java">@Override
public Bundle call(String method, String arg, Bundle extras) {
	return null;
}
</code></pre>
<p>参数列表：</p>
<ul>
<li>method: 根据这个method的值，我们就可以知道调用方想要执行什么操作</li>
<li>arg: 这个参数可以让调用发传递简单的String类型的数据过来，要想传递其他类型的数据需要使用到第三个参数Bundle</li>
<li>extras: 上面已经说了，可以让调用方传递一些数据过来，因为涉及到IPC操作，所以需要使用Bundle</li>
</ul>
<p>这里我们首先创建一个BasePreferencesProvider抽象类继承ContentProvider，内部先空实现query、getType、insert、delete、update这个几个方法，因为在本例中这几个方法用不到，所以为了主ContentProvider类的结构清晰，所以这里先空实现这几个方法.</p>
<pre><code class="language-java">public abstract class BasePreferencesProvider extends ContentProvider {
    @Nullable
    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
        return null;
    }

    @Nullable
    @Override
    public String getType(Uri uri) {
        return null;
    }

    @Nullable
    @Override
    public Uri insert(Uri uri, ContentValues values) {
        return null;
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        return 0;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        return 0;
    }
}
</code></pre>
<p>然后创建我们的PreferencesProvider继承上面的BasePreferencesProvider，PreferencesProvider在里面封装了对SharedPreferences的所有操作。当然，这里为了简单，只实现了String和boolean的实现，其他类型的操作实现类似。</p>
<pre><code class="language-java">public class PreferencesProvider extends BasePreferencesProvider {

    // putString()方法标识
    public static final String METHOD_PUT_STRING = &quot;put_string&quot;;
    // getString()方法标识
    public static final String METHOD_GET_STRING = &quot;get_string&quot;;
    // putBoolean()方法标识
    public static final String METHOD_PUT_BOOLEAN = &quot;put_boolean&quot;;
    // getBoolean()方法标识
    public static final String METHOD_GET_BOOLEAN = &quot;get_boolean&quot;;

    public static final String EXTRA_KEY = &quot;key&quot;;
    public static final String EXTRA_VALUE = &quot;value&quot;;
    public static final String EXTRA_DEFAULT_VALUE = &quot;default_value&quot;;

    private SharedPreferences mPreferences;

    @Override
    public boolean onCreate() {
        // Provider创建时获取SharedPreferences
        mPreferences = getContext().getSharedPreferences(&quot;app_config&quot;, Context.MODE_PRIVATE);
        return false;
    }

    @Nullable
    @Override
    public Bundle call(String method, String arg, Bundle extras) {
        // 用于将数据返回给调用方，例如getString()、getBoolean()
        Bundle replyData = null;
        switch (method) {
            case METHOD_PUT_STRING: {
                String key = extras.getString(EXTRA_KEY);
                String value = extras.getString(EXTRA_VALUE);
                // 将值存起来 - putString()
                mPreferences.edit().putString(key, value).commit();
                break;
            }
            case METHOD_GET_STRING: {
                String key = extras.getString(EXTRA_KEY);
                String defValue = extras.getString(EXTRA_DEFAULT_VALUE);
                // 获取到的值 - getString()
                String value = mPreferences.getString(key, defValue);
                replyData = new Bundle();
                // 将获取到的值放进Bundle
                replyData.putString(EXTRA_VALUE, value);
                break;
            }
            case METHOD_PUT_BOOLEAN: {
                String key = extras.getString(EXTRA_KEY);
                boolean value = extras.getBoolean(EXTRA_VALUE);
                // 将值存起来 - putBoolean()
                mPreferences.edit().putBoolean(key, value).commit();
                break;
            }
            case METHOD_GET_BOOLEAN: {
                String key = extras.getString(EXTRA_KEY);
                boolean defValue = extras.getBoolean(EXTRA_DEFAULT_VALUE);
                // 获取到的值 - getBoolean()
                boolean value = mPreferences.getBoolean(key, defValue);
                replyData = new Bundle();
                replyData.putBoolean(EXTRA_VALUE, value);
                break;
            }
        }
        // 将获取到的值返回给调用方，若为put操作，replyData则为null
        return replyData;
    }
}
</code></pre>
<p>上面可以看到，我们首先定义了4个Method操作方法标识。在执行call方法内，根据调用方传进来的method的值，来执行对应的操作。上面例子中只实现了putString()、getString()、putBoolean()、getBoolean()这四个操作，其他类似int等操作实现一模一样。</p>
<p>编写完Provider后，不要忘记在AndroidManifest.xml文件中注册我们的Provider</p>
<pre><code class="language-xml">&lt;provider
    android:name=&quot;.provi.PreferencesProvider&quot;
    android:authorities=&quot;com.melodyxxx.sharedpreferencesdemo.sp&quot;/&gt;
</code></pre>
<p>这样注册Provider后，Provider是运行在主进程的，也可以指定让其运行在其他进程，如下：</p>
<pre><code class="language-xml">&lt;provider
    android:name=&quot;.provi.PreferencesProvider&quot;
    android:authorities=&quot;com.melodyxxx.sharedpreferencesdemo.sp&quot;
    android:process=&quot;:remote&quot;/&gt;
</code></pre>
<p>这样就讲其指定运行在私有的remote进程了</p>
<p>最后为了方便调用方调用，我们还需要创建PreferencesUtils类再封装一层操作：</p>
<pre><code class="language-java">public class PreferencesUtils {

    private static final Uri sUri = Uri.parse(&quot;content://com.melodyxxx.sharedpreferencesdemo.sp&quot;);

    public static void putString(Context context, String key, String value) {
        Bundle data = new Bundle();
        data.putString(PreferencesProvider.EXTRA_KEY, key);
        data.putString(PreferencesProvider.EXTRA_VALUE, value);
        context.getContentResolver().call(sUri, PreferencesProvider.METHOD_PUT_STRING, null, data);
    }

    public static String getString(Context context, String key, String defValue) {
        String value = null;
        Bundle data = new Bundle();
        data.putString(PreferencesProvider.EXTRA_KEY, key);
        data.putString(PreferencesProvider.EXTRA_DEFAULT_VALUE, defValue);
        Bundle replyData = context.getContentResolver().call(sUri, PreferencesProvider.METHOD_GET_STRING, null, data);
        return replyData.getString(PreferencesProvider.EXTRA_VALUE);
    }

    public static void putBoolean(Context context, String key, boolean value) {
        Bundle data = new Bundle();
        data.putString(PreferencesProvider.EXTRA_KEY, key);
        data.putBoolean(PreferencesProvider.EXTRA_VALUE, value);
        context.getContentResolver().call(sUri, PreferencesProvider.METHOD_PUT_BOOLEAN, null, data);
    }

    public static boolean getBoolean(Context context, String key, boolean defValue) {
        Bundle data = new Bundle();
        data.putString(PreferencesProvider.EXTRA_KEY, key);
        data.putBoolean(PreferencesProvider.EXTRA_DEFAULT_VALUE, defValue);
        Bundle replyData = context.getContentResolver().call(sUri, PreferencesProvider.METHOD_GET_BOOLEAN, null, data);
        return replyData.getBoolean(PreferencesProvider.EXTRA_VALUE);
    }

}
</code></pre>
<p>上面的封装也是很简单的，注意Uri不要指定错了。同样也写了对应的putString()、getString()、putBoolean()、getBoolean()、内部都是根据指定的Uri调用了PreferencesProvider的call方法。在多进程情况下时，这里调用是跨进程的，所有对SharedPreferences的操作最终都会在PreferencesProvider所在的remote进程中完成，从而保证了SharedPreferences读写的安全性，保证了在各个进程读取到的数据是正确的。</p>
<p>最后，就是验证了，我将此例子放到自己的项目中运行测试了下，在运行在主进程中的Activity中通过PreferencesUtils修改值后，然后另一个在其他进程中的Service立马通过PreferencesUtils将值取出打印：</p>
<p>put操作:</p>
<pre><code>Log.d(&quot;sp_test&quot;, &quot;Put String :  &quot; + namesList.get(position));
PreferencesUtils.putString(LiveWallpaperSettingsActivity.this, &quot;weather_type&quot;, namesList.get(position));
</code></pre>
<p>get操作:</p>
<pre><code>String weather_type = PreferencesUtils.getString(context, &quot;weather_type&quot;, &quot;unknown&quot;);
Log.d(&quot;sp_test&quot;, &quot;Get String :  &quot; + weather_type);
</code></pre>
<p>最后运行看打印的Log:</p>
<figure data-type="image" tabindex="1"><img src="http://i.imgur.com/ixQq3FF.png" alt=""></figure>
<p>根据Log打印的PID可以看到这里put和get操作不在同一进程，取出值是正确的，所以这种利用ContentProvider封装SharedPreferences是可行的。</p>
<h3 id="四-最后">四、最后：</h3>
<p>本文只探讨的是SharedPreferences在多进程中如何安全的使用，当然在多进程也可以不使用SharedPreferences，例如可以使用数据库来存储配置文件和其他的数据，方法也有很多。由于技术有限，文中难免写的不对地方，也欢迎指正。</p>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://imhanjie.github.io//post/Messenger的使用方法以及源码分析">
              <h3 class="post-title">
                下一篇：Messenger的使用方法以及源码分析
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">Keep Alive.</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://imhanjie.github.io//atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
